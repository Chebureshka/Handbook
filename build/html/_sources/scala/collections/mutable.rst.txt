.. include:: ../../defs.rst

Реализации неизменяемых коллекций
************************************

`scala.collection.mutable <https://docs.scala-lang.org/ru/overviews/collections-2.13/concrete-mutable-collection-classes.html>`_

.. figure:: ../../_static/photo_2020-06-01_01-17-57.jpg

Seq
=======


ArraySeq
----------
Наследуется от IndexedSeq

Последовательные массивы - это изменяемые массивы со свойствами последовательности фиксированного размера, которые хранят свои элементы внутри Array[Object]

Вам стоит использовать ArraySeq, если вам нужен массив из-за его показателей производительности, но вы дополнительно хотите использовать обобщеные экземпляры последовательности, 
в которых вы не знаете тип элементов и у которого нет ClassTag который будет предоставлен непосредственно во время исполнения.


ArrayDeque
------------
Наследуется от IndexedSeq
ArrayDeque это последовательность, поддерживающая эффективное добавление элементов как спереди, так и сзади. Реализован на основе массива с изменяемым размером.

Double-ended queue that internally uses a resizable circular buffer


StringBuilder
--------------
Наследуется от IndexedSeq

Так же, как буферизированный массив полезен для создания массивов, а буферизированный список полезен для построения списков, StringBuilder полезен для создания строк.

Обертка над java.lang.StringBuilder


Stack
------------
Наследуется от IndexedSeq

LIFO, основан на ArrayDeque


Queue
------------
Наследуется от IndexedSeq

FIFO, основан на ArrayDeque


ArrayBuffer
------------
Наследуется от IndexedSeq, Buffer

ArrayBuffer - буферизированный массив в своем буфере хранит массив и его размер. Большинство операций с буферизированным массивом выполняются с той же скоростью, что и с массивом, 
так как операции просто обращаются и изменяют исходный массив. Кроме того он может эффективно добавлять данные к своему концу. Присоединение элемента к такому массиву занимает амортизированное константное время.


ListBuffer
-----------
Наследуется от Buffer

Похож на буферизированный массив, за исключением того, что он базируется на связанном списке, а не массиве


PriorityQueue
==============

This class implements priority queues using a heap


Map
================


HashMap
-----------
Основываются на хэш-таблицах


WeakHashMap
------------
Ослабленный хэш-мап это специальный вид хэш-мапы, при которой сборщик мусора не ходит по ссылкам с мапы к её ключам. 
Это означает, что ключ и связанное с ним значение исчезнут из мапы, если на ключ не будет никаких ссылок. 


ListMap
-----------
Ассоциативная коллекция выраженный связанным списоком ключей и значений.

TreeMap
-----------
Ассоциативная коллекция на красно-черном дереве. С ключами в качестве узлов дерева и элементами в качетве листьев.


LinkedHashMap
---------------
Наследуется от SeqMap

Помимо хранения ключ-значение, как в обычной HashMap добавляется гарантия на порядок добавления, при итерировании, за счет хранения ссылок на предыдущий элемент и последующий в элементах значений мапы.
 

Set
================


HashSet
-----------
Основываются на хэш-таблицах


LinkedHashSet
--------------
Реализован на основе LinkedHashMap


BitSet
-----------
Наследуется от SortedSet

Изменяемый набор типа mutable.BitSet практически такойже как и неизменяемый набор, за исключением того, что он при изменении сам меняется.
