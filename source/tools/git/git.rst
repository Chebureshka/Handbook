.. include:: ../../defs.rst

Git
######################

.. contents::
    :local:

Определения
************************************
.. container:: left-col

    Git является распределенным, то есть не зависит от одного центрального сервера, на котором хранятся файлы. 
    Вместо этого он работает полностью локально, сохраняя данные в папках на жестком диске, которые называются репозиторием.

.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки:

        `Git. Шпаргалка <https://eax.me/git-commands/>`_

        `Git за полчаса: руководство для начинающих <https://proglib.io/p/git-for-half-an-hour/>`_

        `GitHub: Remote <https://help.github.com/en/github/importing-your-projects-to-github/adding-an-existing-project-to-github-using-the-command-line>`_

Комманды 
*************************************
.. container:: left-col

    .. container:: code-markup

        Конфигурация опций
            .. code-block:: shell

                > git config --global user.name "My Name"
                > git config --global user.email myEmail@example.com

            Теперь каждое действие будет отмечено именем и почтой

        Создание нового репозитория
            git хранит свои файлы и историю прямо в папке проекта

            .. code-block:: shell

                > git init

            Это включит приложение в этой конкретной папке и создаст скрытую директорию ``.git``, где будет храниться история репозитория и настройки.

        Определение состояния
            Показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее.
            А так же список сделанных изменений в файлах, создание файлов и тд.

            .. code-block:: shell

                > git status

        Подготовка файлов
            Добавляет существующий файл в отслеживаемые (в область подготовки файлов), т.е. теперь данный файл может быть закоммичен в репозиторий.

            Сперва область подготовки пустая, но затем добавляются в нее файлы (или части файлов, или даже одиночные строчки) командой add.

            .. code-block:: shell

                > git add fileName.txt
                > git add -A

        Коммит(фиксация изменений)
            Коммит представляет собой состояние репозитория в определенный момент времени.

            Чтобы зафиксировать изменения, нужно хотя бы одно изменение в области подготовки (среди отслеживаемых файлов)

            .. code-block:: shell

                git commit -m "Initial commit."

            Эта команда создаст новый коммит со всеми изменениями из области подготовки (добавление файла ``fileName.txt``). 

            Ключ ``-m`` и сообщение «Initial commit.» — это созданное пользователем описание всех изменений, включенных в коммит.


        Удаленные репозитории
            После комманды (``commit``) коммит является локальным — существует только в директории ``.git`` в файловой системе.

            1. Подключение к удаленному репозиторию
                Чтобы загрузить что-нибудь в удаленный репозиторий, сначала нужно к нему подключиться
                Проект может иметь несколько удаленных репозиториев одновременно. Обычно главный репозиторий называется origin.

                .. code-block:: shell

                    > git remote add origin https://uri.git

            2. Отправка изменений на сервер
                Этот процесс происходит каждый раз, когда мы хотим обновить данные в удаленном репозитории.

                .. code-block:: shell

                    > git push origin master

                (**master** — это ветка по умолчанию для всех репозиториев)

            3. Клонирование репозитория
                .. code-block:: shell

                    > git clone https://uri.git

                Новый локальный репозиторий создается автоматически

            4. Запрос изменений с сервера
                Изменения в репозитории, другие пользователи могут скачать при помощи команды ``pull``.

                .. code-block:: shell

                    > pull origin master

        Ветвление
            Во время разработки новой функциональности считается хорошей практикой работать с копией оригинального проекта, которую называют веткой. 

            Ветви имеют свою собственную историю и изолированные друг от друга изменения до тех пор, пока вы не решаете слить изменения вместе.

            1. Создание новой ветки
                .. code-block:: shell

                    > git branch branchName

                Это создаст новую ветку, пока что точную копию ветки **master**.

                .. code-block:: shell
                    :caption: Удаляет ветку

                    > git branch -d branchName



            2. Переключение между ветками
                .. code-block:: shell

                    > git branch
                    |   branchName
                    |   * master

                **master** — это активная ветка, она помечена звездочкой

                .. code-block:: shell
                    :caption: Переключает на указанную ветку

                    > git checkout branchName

            3. Слияние веток
                Слияние принимает содержимое ветки источника и объединяет их с целевой веткой. В этом процессе изменяется только целевая ветка. История исходных веток остается неизменной.

                .. code-block:: shell

                    > git merge branchName # Позволяет слить азанную ветку с текущей

                    > git merge branchName master

            Git Rebase
                `Rebase <https://habr.com/ru/post/432420/>`_ — еще один способ перенести изменения из одной ветки в другую. Rebase сжимает все изменения в один «патч». Затем он интегрирует патч в целевую ветку

                В отличие от слияния, перемещение перезаписывает историю, потому что она передает завершенную работу из одной ветки в другую. В процессе устраняется нежелательная история.

                .. code-block:: shell

                    > git checkout branchName
                    > git rebase master

                Это перемещает всю ветку **branchName** в **master** ветку. История проекта изменяется, создаются новые коммиты для каждого коммита в основной ветке (**master**).

            GitFlow 
                https://datasift.github.io/gitflow/IntroducingGitFlow.html


        Отслеживание изменений, сделанных в коммитах
            У каждого коммита есть свой уникальный идентификатор в виде строки цифр и букв. Чтобы просмотреть список всех коммитов и их идентификаторов, можно использовать команду ``log``

                .. code-block:: shell

                    > git log

            Идентификаторы довольно длинные, но для работы с ними не обязательно копировать их целиком — первых нескольких символов будет вполне достаточно

                ``(b10cc1238e355c02a044ef9f9860811ff605c9b4 -> b10cc123)``

            Чтобы посмотреть, что нового появилось в коммите, можно воспользоваться командой ``show``

                .. code-block:: shell

                    > git show b10cc123

            Чтобы увидеть разницу между двумя коммитами, используется команда ``diff`` (с указанием промежутка между коммитами)

                .. code-block:: shell

                    > git diff 09bd8cc..ba25c0ff

        Возвращение файла к предыдущему состоянию
            Гит позволяет вернуть выбранный файл к состоянию на момент определенного коммита.

            ``checkout`` может быть использована для переключения между коммитами.

            .. code-block:: shell

                > git checkout 09bd8cc1 fileName.txt

        Исправление коммита
            Комманда ``commit —amend`` добавит все из последнего коммита в область подготовленных файлов и попытается сделать новый коммит. 
            Это дает возможность поправить комментарий или добавить недостающие файлы в область подготовленных файлов.

            Для более сложных исправлений, например, не в последнем коммите или если вы успели отправить изменения на сервер, нужно использовать ``revert``. 
            Эта команда создаст коммит, отменяющий изменения, совершенные в коммите с заданным идентификатором.

            .. tip::
                Самый последний коммит может быть доступен по алиасу HEAD

            .. code-block:: shell

                > git revert HEAD
                > git revert b10cc123

            При отмене старых коммитов нужно быть готовым к тому, что возникнут конфликты. Такое случается, если файл был изменен еще одним, более новым коммитом

        Разрешение конфликтов при слиянии
            Иногда конфликты исправляются автоматически, но обычно с этим приходится разбираться вручную — решать, какой код остается, а какой нужно удалить.

            .. code-block:: shell

                > git mergetool

        Настройка ``.gitignore``
            В большинстве проектов есть файлы или целые директории, в которые мы не хотим (и, скорее всего, не захотим) коммитить. 
            Мы можем удостовериться, что они случайно не попадут в ``git add -A`` при помощи файла ``.gitignore``

            1. Создайте вручную файл под названием ``.gitignore`` и сохраните его в директорию проекта.

            2. Внутри файла перечислите названия файлов/папок, которые нужно игнорировать, каждый с новой строки.

            3. Файл ``.gitignore`` должен быть добавлен, закоммичен и отправлен на сервер, как любой другой файл в проекте.
