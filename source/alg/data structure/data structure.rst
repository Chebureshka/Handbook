.. include:: ../../defs.rst

Структуры данных
*******************************************************

.. contents::
    :local:


Поисковые структуры данных
============================
.. container:: left-col

    Структура данных реализующая эффективный поиск конкретных элементов множества.

    В **статическом** бинарном дереве поиска не происходит поворотов вокруг ребер. 
    Его оптимальность зависит только от начального положения дерева. Это отличает его от **динамического** дерева, в котором повороты вокруг ребер разрешены.

    **Offline** дерево поиска получает все запросы сразу и может использовать дополнительную память и вычисления для нахождения наиболее оптимальной последовательности обработки запросов. 
    Стоимость работы дерева поиска для заданной последовательности ключей это стоимость доступа к каждому ключу и модификации дерева, 
    и она не зависит от того, сколько времени мы потратили, чтобы найти оптимальную последовательность.

    **Online** дерево поиска получает следующий запрос, только когда ответит на текущий, соответственно время работы пропорциональное стоимости исполнения запросов. 
    Таким является `Splay-дерево`_.


.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки:

        `Структуры данных: бинарные деревья. Часть 2: обзор сбалансированных деревьев <https://habr.com/ru/post/66926/>`_

        `Поисковые структуры данных (neerc.ifmo) <http://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%BE%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D1%8B%D0%B5_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85>`_


Двоичное дерево поиска
------------------------
.. container:: left-col

    Бинарное дерево поиска обладает следующим свойством: если x — узел бинарного дерева с ключом k, то все узлы в левом поддереве должны иметь ключи, меньшие k, а в правом поддереве большие k.

    .. figure:: ../../_static/Binary_search_tree.svg.png

.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки:

        `Двоичное дерево поиска (neerc.ifmo) <http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0,_%D0%BD%D0%B0%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F>`__

    .. table::
        :widths: auto

        +------------+------------+------------+-------------+
        | Insert     | Delete     | Search     | Память      |
        +============+============+============+=============+
        | log(n)     | log(n)     | log(n)     |   n         |
        +------------+------------+------------+-------------+
        | n          | n          | n          |   n         |
        +------------+------------+------------+-------------+
    
АВЛ-дерево
------------------------
.. container:: left-col

    Сбалансированное двоичное дерево поиска, в котором поддерживается следующее свойство: для каждой его вершины высота её двух поддеревьев различается не более чем на 1.

    .. hlist::
        :columns: 2

        * .. figure:: ../../_static/300px-Avl_u1.jpg

            Малое левое вращение

        * .. figure:: ../../_static/300px-Avl_u2.jpg

            Большое левое вращение

.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки:

        `АВЛ-дерево (neerc.ifmo) <https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%92%D0%9B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE>`__

    .. table::
        :widths: auto

        +------------+------------+------------+-------------+
        | Insert     | Delete     | Search     | Память      |
        +============+============+============+=============+
        | log(n)     | log(n)     | log(n)     |   n         |
        +------------+------------+------------+-------------+



2-3 дерево
------------------------
.. container:: left-col

    Структура данных, представляющая собой сбалансированное дерево поиска, такое что из каждого узла может выходить две или три ветви и глубина всех листьев одинакова. 
    Является частным случаем `B+-дерево`_.

    .. figure:: ../../_static/400px-23treemain.png

    * Нелистовые вершины имеют либо **два потомка и одно поле**, либо **три потомка и два поля**.
    * Нелистовая вершина, имеющая **двух сыновей**, хранит **максимум левого поддерева**. 
    * Нелистовая вершина, имеющая **трех сыновей**, хранит два значения: первое значение хранит **максимум левого поддерева**, второе **максимум центрального поддерева**.
    * Все листья лежат на одной глубине

.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки:

        `2-3 дерево (neerc.ifmo) <http://neerc.ifmo.ru/wiki/index.php?title=2-3_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE>`__

        `Википедия <https://ru.wikipedia.org/wiki/2-3-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE>`_

    .. table::
        :widths: auto

        +------------+------------+------------+-------------+
        | Insert     | Delete     | Search     | Память      |
        +============+============+============+=============+
        | log(n)     | log(n)     | log(n)     |   n         |
        +------------+------------+------------+-------------+






B-дерево
--------
.. container:: left-col

    Сильноветвящееся сбалансированное дерево поиска, позволяющее проводить поиск, добавление и удаление элементов за O(log).

    B-дерево является идеально сбалансированным, то есть глубина всех его листьев одинакова.

    .. figure:: ../../_static/572px-B3insa.png

    Эффективно для поиска по диску или другому источнику информации считывание с которого можно производить последовательными блоками.

.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки:

        `B-дерево (neerc.ifmo) <http://neerc.ifmo.ru/wiki/index.php?title=B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE>`__

        `B-tree <https://habr.com/ru/post/114154/>`__

    .. table::
        :widths: auto

        +------------+------------+------------+-------------+
        | Insert     | Delete     | Search     | Память      |
        +============+============+============+=============+
        | log(n)     | log(n)     | log(n)     |   n         |
        +------------+------------+------------+-------------+


B+-дерево
----------------------------
.. container:: left-col

    В `B-дерево`_ во всех вершинах хранятся ключи вместе с сопутствующей информацией. 
    В B+-деревьях вся информация хранится в листьях, а во внутренних узлах хранятся только копии ключей. 
    Таким образом удается получить максимально возможную степень ветвления во внутренних узлах. 
    
    Кроме того, листовой узел может включать в себя указатель на следующий листовой узел для ускорения последовательного доступа, что решает одну из главных проблем B-деревьев.

    .. figure:: ../../_static/B-Tree-Deletions.gif

        Удаление значений из B+ дерева (схожее при этом с 2-3 деревом, кроме последовательностей листьев и хранения не максимума левого поддерева, а минимума правого)

.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки:

        `B+-дерево (neerc.ifmo) <http://neerc.ifmo.ru/wiki/index.php?title=B%2B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE>`__

    .. table::
        :widths: auto

        +------------+------------+------------+-------------+
        | Insert     | Delete     | Search     | Память      |
        +============+============+============+=============+
        | log(n)     | log(n)     | log(n)     |   n         |
        +------------+------------+------------+-------------+


Красно-черное дерево
-------------------------
.. container:: left-col

    Сбалансированное двоичное дерево поиска, в котором баланс осуществляется на основе "цвета" узла дерева, который принимает только два значения: "красный" (англ. red) и "чёрный" (англ. black). 
    При этом все листья дерева являются фиктивными и не содержат данных, но относятся к дереву и являются чёрными. Для экономии памяти фиктивные листья можно сделать одним общим фиктивным листом.

    Каждый узел промаркирован красным или чёрным цветом:
    
        * Корень и конечные узлы (листья) дерева — чёрные. 
        * У красного узла родительский узел — чёрный. 
        * Чёрный узел может иметь чёрного родителя.
        * Все простые пути из любого узла x до листьев содержат одинаковое количество чёрных узлов.

    .. figure:: ../../_static/800px-RBT.jpg

.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки:

        `Красно-черное дерево (neerc.ifmo) <http://neerc.ifmo.ru/wiki/index.php?title=%D0%9A%D1%80%D0%B0%D1%81%D0%BD%D0%BE-%D1%87%D0%B5%D1%80%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE>`__


    .. table::
        :widths: auto

        +------------+------------+------------+-------------+
        | Insert     | Delete     | Search     | Память      |
        +============+============+============+=============+
        | log(n)     | log(n)     | log(n)     |   n         |
        +------------+------------+------------+-------------+

    .. raw:: html 

        <iframe width="560" height="315" src="https://www.youtube.com/embed/a9EwBVLQ364" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


Вставка элемента
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.. container:: left-col

    Вставляется узел, так-же как и в двоичное дерево поиска, при этом он окрашен в красный цвет, так же к нему добавляется 2 конечных черных узла (NIL).
    Так как узел красный баланс черной высоты не нарушается.

    * Если родительский узел вставляемого узла - **черный**: 
    
        Ничего перекрашивать не надо, так как все условия существования дерева соблюдены.

    * Если родительский узел вставляемого узла - **красный**, есть два случая решения проблемы двух красных узлов (в зависимости от узла дяди):

        .. hlist::
            :columns: 2

            * Поворот поддерева 
            
                .. figure:: ../../_static/250px-Untitled-2.png

            * Перекраска поддерева
            
              .. figure:: ../../_static/200px-Untitled-1.png

        При перекраске поддерева процесс повторяется для всех родительских узлов пока условие валидности не будет достигнуто.


.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки:

        `Добавление вершины в красно – черном дереве <https://studfile.net/preview/3651697/page:6/>`_

    .. raw:: html

        <iframe width="560" height="315" src="https://www.youtube.com/embed/g6TQpPa3l1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


Декартово дерево 
----------------
.. container:: left-col

    Позволяет хранить и искать координаты на декартовой плоскости.

    Если рисовать бинарное дерево на плоскости, ключ будет соответствовать x-координате вершины (за счет упорядоченности). 

    Тогда можно ввести и y-координату (назавем ее высотой), которая будет обладать следующим свойством: высота вершины больше высоты детей (heap).

    .. figure:: ../../_static/a10a744def8f325a1019502ecc175ef6.png

.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки:

        `Декартово дерево: Описание, операции, применения <https://habr.com/ru/post/101818/>`__

        `Декартово дерево (neerc.ifmo) <http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B5%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D0%B2%D0%BE_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE>`__

    .. table::
        :widths: auto

        +------------+------------+------------+-------------+
        | Insert     | Delete     | Search     | Память      |
        +============+============+============+=============+
        | log(n)     | log(n)     | log(n)     |   n         |
        +------------+------------+------------+-------------+
        | n          | n          | n          |   n         |
        +------------+------------+------------+-------------+



Splay-дерево 
--------------
.. container:: left-col

    Двоичное дерево позволяет находить быстрее те данные, которые использовались недавно, за счёт перемещения к корню. Относится к разряду сливаемых деревьев.

.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки:

        `Splay-дерево (neerc.ifmo) <http://neerc.ifmo.ru/wiki/index.php?title=Splay-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE>`__


    .. table::
        :widths: auto

        +------------+------------+------------+-------------+
        | Insert     | Delete     | Search     | Память      |
        +============+============+============+=============+
        | log(n)     | log(n)     | log(n)     |   n         |
        +------------+------------+------------+-------------+
        | n          | n          | n          |   n         |
        +------------+------------+------------+-------------+


Список с пропусками 
---------------------
.. container:: left-col

    Вероятностная структура данных, позволяющая в среднем за O(log(n)) времени выполнять операции добавления, удаления и поиска элементов.

    Список с пропусками состоит из нескольких уровней, на каждом из которых находится отсортированный связный список. 
    На самом нижнем (первом) уровне располагаются все элементы. 
    Дальше около половины элементов в таком же порядке располагаются на втором, почти четверть — на третьем и так далее, 
    но при этом известно, что если элемент расположен на уровне i, то он также расположен на всех уровнях, номера которых меньше i.

    .. figure:: ../../_static/600px-Skip_list_add_element.gif

.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки:

        `Список с пропусками (neerc.ifmo)  <http://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D1%81_%D0%BF%D1%80%D0%BE%D0%BF%D1%83%D1%81%D0%BA%D0%B0%D0%BC%D0%B8>`__

        `Википедия <https://ru.wikipedia.org/wiki/Список_с_пропусками>`__

        `Еще раз про skiplist… <https://habr.com/ru/post/139870/>`__

    .. table::
        :widths: auto

        +------------+------------+------------+-------------+
        | Insert     | Delete     | Search     | Память      |
        +============+============+============+=============+
        | log(n)     | log(n)     | log(n)     |   n         |
        +------------+------------+------------+-------------+
        | n          | n          | n          |   n         |
        +------------+------------+------------+-------------+


Цифровой бор
-------------
.. container:: left-col

    Цифровой бор, Быстрый цифровой бор, Сверхбыстрый цифровой бор

    Бор, в котором в качестве строк используются двоичные записи чисел, включая ведущие нули.



Tango-дерево 
------------
.. container:: left-col

    Online бинарное дерево поиска.

    Рассмотрим бинарное дерево поиска. Изначально сделаем все левые ребра жирными. Разобьем наше дерево на жирные пути.
    
    |dl| **Жирный путь** **(англ. Prefered path)** — *максимальный по включению путь, состоящий из жирных ребер*.


    .. figure:: ../../_static/400px-DariaPicture7.png

    Каждый из этих жирных путей организуем в свое splay-дерево. `Splay-дерево`_ может быть построено как угодно.

    Из каждой вершины каждого splay-дерева создадим вспомогательную ссылку на корень другого splay-дерева, в котором лежит ее ребенок, связанный с ней нежирным ребром в исходном бинарном дереве поиска (при этом ссылка ставится на само дерево, а не на ребенка).

    Корнем tango-дерева будет являться splay-дерево, которое есть жирный путь от корня исходного бинарного дерева поиска.


    .. figure:: ../../_static/600px-DariaPicture8.png

    .. note::

        Таким образом, все наши ключи организуют иерархичную структуру — Tango-дерево.

        Каждый жирный путь — splay-дерево, и каждая вершина дерева указывает на корень другого splay-дерева, в котором лежит сын вершины по нежирному ребру.

        Глубина tango-дерева :math:`log(n)`

        Общее время работы дерева :math:`( M + K ) ⋅ log(log(n))`, где :math:`K` — число изменений жирных ребер, :math:`M` — число запросов.

        Операций первого становления ребра жирным — :math:`O(log(n))`, это дает несущественный вклад в асимптотику.

.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки:

        `Tango-дерево (neerc.ifmo) <http://neerc.ifmo.ru/wiki/index.php?title=Tango-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE>`__

        `Википедия <https://en.wikipedia.org/wiki/Tango_tree>`__

        `Tango Tree Data Structure <https://www.geeksforgeeks.org/tango-tree-data-structure/>`__
        


Поиск элемента
^^^^^^^^^^^^^^^
.. container:: left-col

    Поиск элемента в tango-дереве схож с поиском в обычном дереве поиска. |br|
    Начинаем с поиска в жирном пути корня tango-дерева — splay-дереве. |br|
    Если текущий жирный путь не содержит искомый элемент, то сделаем переход по вспомогательной ссылке (красная стрелка в tango-дереве) и осуществим поиск в новом жирном пути (splay-дереве). 

    .. note::
        Поиск в splay-дереве (синее дерево в splay-дереве) работает за высоту от количества вершин (количество вершин — длина жирного пути (:math:`log(n)`)) — то есть за :math:`log(log(n))`
        
        Поиск во всем дереве соответствует (:math:`log(log(n))`)⋅ число проходов по нежирному ребру.

.. container:: right-col

    .. container:: example-block

        .. toggle-header::
            :header: Пример

            .. list-table:: 


                * - .. thumbnail:: ../../_static/400px-DariaPicture4.png

                        Изменение жирных ребер в бинарном дереве поиска

                  - .. thumbnail:: ../../_static/400px-DariaPicture14.png

                        Соответствие tango-дерева текущему бинарному дереву поиска


                * - .. thumbnail:: ../../_static/400px-DariaPicture5.png

                        Изменение жирных ребер в бинарном дереве поиска

                  - .. thumbnail:: ../../_static/400px-DariaPicture13.png

                        Соответствие tango-дерева текущему бинарному дереву поиска


                * - .. thumbnail:: ../../_static/400px-DariaPicture6.png

                        Изменение жирных ребер в бинарном дереве поиска

                  - .. thumbnail:: ../../_static/600px-DariaPicture8(1).png

                        Соответствие tango-дерева текущему бинарному дереву поиска




Приоритетные очереди
=====================
.. container:: left-col

    Абстрактная структура данных наподобие стека или очереди, где у каждого элемента есть приоритет. 
    Элемент с более высоким приоритетом находится перед элементом с более низким приоритетом. 
    
    Обычно приоритетные очереди реализуются с помощью куч.




Двоичная куча
--------------
.. container:: left-col

    Двоичная куча - Такое двоичное дерево, для которого выполнены три условия:

        * Значение в любой вершине не меньше, чем значения её потомков.
        * Глубина листьев (расстояние до корня) отличается не более чем на 1 слой.
        * Последний слой заполняется слева направо.

    .. figure:: ../../_static/325px-Min_heap.png

        Пример кучи для минимума

    .. figure:: ../../_static/325px-Min_heap_array.png

        Хранение кучи в массиве, красная стрелка — левый сын, зеленая — правый

.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки:

        `Двоичная куча (neerc.ifmo) <https://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D0%BA%D1%83%D1%87%D0%B0>`__

        `Википедия <https://ru.wikipedia.org/wiki/Куча_(структура_данных)>`__


    .. table::
        :widths: auto

        +--------------------+----------------------+-----------+---------------------+----------+
        | Найти |br| минимум | Удалить |br| минимум | Добавить  | Уменьшить |br| ключ |  Слияние |
        +====================+======================+===========+=====================+==========+
        |   Θ(1)             |      Θ(log n)        | Θ(log n)  |  Θ(log n)           |  Θ(n)    |
        +--------------------+----------------------+-----------+---------------------+----------+


            

Базовые процедуры
^^^^^^^^^^^^^^^^^^^^^^^^^^^
.. container:: left-col

    .. rubric:: Восстановление свойств кучи

    .. container:: code-markup

        ``siftDown`` 
            Если значение измененного элемента увеличивается, то свойства кучи восстанавливаются функцией ``siftDown``.

            Работа процедуры: если i-й элемент меньше, чем его сыновья, всё поддерево уже является кучей, и делать ничего не надо.
            В противном случае меняем местами i-й элемент с наименьшим из его сыновей, после чего выполняем ``siftDown`` для этого сына. Процедура выполняется за время :math:`O(log(n))`.

        ``siftUp`` 
            Если значение измененного элемента уменьшается, то свойства кучи восстанавливаются функцией ``siftUp``.

            Работа процедуры: если элемент больше своего отца, условие 1 соблюдено для всего дерева, и больше ничего делать не нужно. Иначе, мы меняем местами его с отцом. 
            После чего выполняем ``siftUp`` для этого отца. Иными словами, слишком маленький элемент всплывает наверх. Процедура выполняется за время :math:`O(log(n))`


.. container:: left-col

    .. rubric:: Извлечение минимального элемента

    Выполняет извлечение минимального элемента из кучи за время :math:`O(log(n))`. 
    Извлечение выполняется в четыре этапа:

        1. Значение корневого элемента (он и является минимальным) сохраняется для последующего возврата.
        2. Последний элемент копируется в корень, после чего удаляется из кучи.
        3. Вызывается ``siftDown`` для корня.
        4. Сохранённый элемент возвращается.

.. container:: right-col

    .. container:: example-block

        .. toggle-header::
            :header: Пример извлечения минимального элемента

            |br| Здесь извлечение происходит не через ``siftDown``, и лишь демонстрирует общий концепт удаления минимума.

            .. thumbnail:: ../../_static/binary_ex_4.gif

                Пример извлечения минимального элемента

.. container:: left-col

    .. rubric:: Добавление нового элемента

    Выполняет добавление элемента в кучу за время :math:`O(log(n))`.
    Добавление произвольного элемента в конец кучи, и восстановление свойства упорядоченности с помощью процедуры ``siftUp``.



Персистентные структуры данных
================================
.. container:: left-col

        Структуры данных, которые при внесении в них каких-то изменений сохраняют все свои предыдущие состояния и доступ к этим состояниям.

.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки:

        `Персистентные структуры данных (neerc.ifmo) <http://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%B5%D1%80%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BD%D1%82%D0%BD%D1%8B%D0%B5_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85>`__


Персистентный стек 
-----------------------
.. container:: left-col

    .. container:: code-markup

        ``push(x, i)``
            Создает новый элемент со значением x, который ссылается на элемент с номером i как на предыдущий элемент в стеке.

        ``pop(i)``
            Возвращает значение, хранящееся в элементе с номером i и копирует элемент, предыдущий для него.

    .. rubric:: Способ использования:

    Изначально есть один пустой стек:

        .. figure:: ../../_static/b5bb212f3702e565498c4412e13242a7.jpg

    ``push(1, 5)``:

        .. figure:: ../../_static/612b6fe1562242b3a455b2abb698dfc9.jpg

        Создается новая вершина со значением 5, ссылающаяся на 1-ую

    ``push(2, 10)`` и ``push(1, 6)``:

        .. figure:: ../../_static/2beb71892fd79b675e095d5432827d03.jpg

        Все 4 стека сейчас верно построены и легко восстанавливаются.

    ``pop(2)``:

        .. figure:: ../../_static/3ab7456751529d76c5f1392d5d3b5fcb.jpg

        Возвращает 5 и копирует 1-ую вершину. Результирующий пятый стек — пустой.

    ``pop(3)``:

        .. figure:: ../../_static/eced2ebbcee643d6c87576b0d3460785.jpg

        pop(3) возвращает 10 и копирует 2-ую вершину. Результат: шестой стек.

.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки: 

        `Персистентный стек <https://habr.com/ru/post/113585//>`__



Бор (Префиксное дерево) 
===========================
.. container:: left-col

    Структура данных для хранения набора строк, представляющая из себя подвешенное дерево с символами на рёбрах. 

    Строки получаются последовательной записью всех символов, хранящихся на рёбрах между корнем бора и терминальной вершиной. 

    Размер бора линейно зависит от суммы длин всех строк, а поиск в бору занимает время, пропорциональное длине образца.

    .. figure:: ../../_static/Бор_sdfg563dfg.jpg

        Бор для набора образцов {he, she, his, hers}

.. container:: right-col

    .. container:: links-block

        .. rubric:: Ссылки: 

        `Бор (neerc.ifmo) <https://neerc.ifmo.ru/wiki/index.php?title=Бор>`__

        `Википедия <https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE>`__