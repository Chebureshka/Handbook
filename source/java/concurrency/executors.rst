.. include:: ../../defs.rst

Executors
********************************

.. figure:: ../../_static/executors.PNG


ThreadPoolExecutor
============================

.. todo:: TODO


Executors
=============

.. todo:: TODO



ForkJoinPull
============
Разделяй и властвуй |br|
`Презентация <../../_static/jeeconf-May2012-forkjoin.pdf>`_

.. raw:: html

    <iframe width="560" height="315" src="https://www.youtube.com/embed/t0dGLFtRR9c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

|br|

Балансировка задач между потоками
---------------------------------

.. warning::
    Содержаться некоторые противроречия, указанные в блоках warning, во внутренней работе, так как многие источники говорят по-разному.
    Вот и хз кому верить Шипилеву или интернету.

    Вот тебе документация, читай: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html

Work arbitrage 
    Внешний ресурс распределяет какой воркер будет брать ту или иную задачу

Work dealing 
    При большой загруженности поток сам отдает задачу "соседу"

Work stealing 
    При отсутствии задач поток забирает задачу у "соседа" (ForkJoinPull)


Внутри ForkJoinPull есть N воркеров. Внутри каждого воркера есть (lock free) очередь задач которую он исполняет, из конца которой другие воркеры могут забрать задачу.

Добавление задач в ForkJoinPull происходит в одну из (случайную) отдельных (входных) очередей для внешних задач (в хвост). Для входных очередей используется синхронизация.

После добавления один из ожидающих воркеров (без задач и без задач у соседей) оповещается, что появилась новая задача.

При появлении задач в очереди воркера, которые еще не исполняются - оповещаются соседние воркеры, которые берут эти самые задачи.

При выполнении разделения задач в воркере (fork) они отправляются ему же в очередь задач (в голову).

При оповещении воркера он сначала смотрит - можно ли у соседей украсть задачу (?), если нет - он идет в очереди входных задач (в случайной последовательности (так как он блокирует очередь), пока не найдет таску).


Операции над RecursiveAction, RecursiveTask
-------------------------------------------

fork 
    Запуск на выполнение новой подзадачи, задачи отправляются в голову. Со стороны воркера формируемые задачи в голове организуют стек (текущая <- [третяя, вторая, первая, ..., то что могут забрать]).

join 
    Семантика приостановления текущей задачи, до завершения указанной.

    - Если в голове очереди текущего воркера есть требуемая задача - он начинает выполнять ее и возвращается по завершению к предыдущей задаче.

    - Если требуемая задача не в голове очереди, но все же есть в ней - выполнить ее и т.д. (чуть менее эффективно)

    - ~ Если требуемой задачи нет в очереди - пытаемся узнать кто ее забрал, и забираем ее обратно, либо забираем поражденные требуемой задачей задачи. 

      .. warning:: 
            Скорее стырим просто другую задачу. Но нужно еще поразбираться!

    - ~ Или же разгребаем свои задачи или помогаем с задачами взявшему.

      .. warning::
            ПРОТИВОРЕЧИТ: Охотимся только за зависимыми задачами (Иначе рискуем starvation'ом внутренних задач под напором внешних). Но Шипилев (вроде) говорит по другому
            
            Или блокируемся (что еще более не выгодно)

    После завершения выполнения другой задачи воркер смотрит появился ли результат, если нет продолжает выполнение других задач.

invokeAll 
    Ожидает выполнения всех переданных тасок. join на них не будет ожидать выполнения.

invoke 
    Вызванный не из потоков ForkJoinPull становится одним из воркеров (commonPool), и далее, как и потоки из ForkJoinPull выполняют fork и join.


Выбор ширины
--------------

.. math:: T = N / (C * L)

T - число, означающее нужно ли дробить задачу на подзадачи (>T) |br|
N - размер задачи |br|
C - количество CPU |br|
L - load factor [10..100]


Блокировка
------------
https://docs.w3cub.com/openjdk~8/java/util/concurrent/forkjoinpool.managedblocker/

~ Блокировки через ManagedBlocker блокирют текущий поток (block) при этом создается новый поток в ForkJoinPull, на котором будут производится исполнения до пробуждения (isReleasable) первого.
